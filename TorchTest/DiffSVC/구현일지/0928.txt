----- 알게된 것 -----

h5형식은 hdf5_path에 이름을 적어 dict???비슷한 형식으로 값을 저장할 수 있는 모양이다.
npy는 이게 안되는 모양인지 그냥 이름을 적고 ---_wave.npy나 ---_feats.npy로 저장하는 모양
wave는 원본 음악 feats는 특징(아마 로그 멜스펙트로그램)을 저장하는 모양이다.

일단 vctk long 모델은 global조건을 안쓰던데, 원래 보코더에는 음성 전체에 영향을 끼치는 전역 조건과,
그렇지 않은 지역 조건이 존재하는 모양이다. 옵션도 따로 있더라
잘 배웠다가 나중에 상황별 악센트 등에도 써먹을 수 있지 않을까 싶음

audio_mel_dataset은 예상대로 pytorch의 dataset 클래스를 상속 받아 사용하며,
음악만 있는것, 멜 스펙트로그램만 있는것, 둘 다 있는 것 3종류를 사용한다(f0즉 기본 주파수를 추가로 저장하는 옵션도 존재함)

----- 단기 목표 -----

Vocoder parallel wavegan의 비공식 라이브러리 코드를 뜯는 중이다.
기존의 파일을 읽어 파일로 저장하는(이 때 확장자는 h5나 npy) 형식에서,
파이프라이닝으로 바꾸는 작업을 하는 중이다.

지금 할일은!
h5나 npy파일로 저장했다가 꺼내서 읽고 다시 저장하고 이런 번거로운 작업을 없애고 한 큐에 보코더 작업을 가능케하도록
파이프라인을 만드는 것이며, 이를 위해 데이터셋에 들어가는 함수나 내부 함수 등을 살펴보는 일이다.

방식은? 일단 전처리, 정규화, 복호화 함수가 모두 npy(가 음원 별로 각각 들어간 list)를 반환하도록 개조했으니,
파일을 하나 파고,
각 파일들에서 어떤 클래스를 사용하고,
그 클래스들이 어떻게 동작하는지 파악한다음,
이를 개조하여 파일경로에서 파일을 읽어오는 대신, npy(들의 리스트)를 받아 이를 클래스 내부의 정보로 갖도록 하며,
getitem으로 최종적으로 가져올 수 있도록 한다.
정상 동작을 하는지 확인했다면 이전에 개조한 함수들 정규화, 복호화 두 개의 경우는 npy list 받았을 때, if 분기로 동작할 수 있도록 한다.
※ 즉, 읽을 파일의 path나 npy list 둘 중 하나를 받아 분기가 나뉘도록 처리해야한다.


----- 작업 노트 -----
